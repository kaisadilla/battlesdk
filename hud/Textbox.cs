using battlesdk.graphics;
using NLog;
using SDL;

namespace battlesdk.hud;
public class Textbox {
    private static readonly Logger _logger = LogManager.GetCurrentClassLogger();

    private unsafe SDL_Renderer* _renderer;
    private string _text;
    private GraphicsTextbox _textboxTex;
    private GraphicsFont _font;

    /// <summary>
    /// The texture generated for the text.
    /// </summary>
    private unsafe SDL_Texture* _stringTex = null;
    /// <summary>
    /// The texture generated for the drop shadow.
    /// </summary>
    private unsafe SDL_Texture* _shadowTex = null;

    /// <summary>
    /// The position of the textbox.
    /// </summary>
    private IVec2 _pos;
    /// <summary>
    /// The size of the textbox.
    /// </summary>
    private IVec2 _size;
    /// <summary>
    /// The width of a line, as defined by the size of the textbox and its padding.
    /// </summary>
    private int _lineWidth;

    /// <summary>
    /// The amount of lines generated by this text.
    /// </summary>
    private int _lines;
    /// <summary>
    /// The current first line shown in the textbox.
    /// </summary>
    private int _currentLine = 0;

    private GraphicsText _txt;

    public unsafe Textbox (
        Renderer renderer,
        int textboxId,
        int fontId,
        IVec2 pos,
        IVec2 size,
        string text
    ) {
        _renderer = renderer.SdlRenderer;
        _text = text;
        _textboxTex = renderer.GetTextboxOrDefault(textboxId);
        _pos = pos;
        _size = size;
        _lineWidth = _size.X - _textboxTex.File.Padding.Left - _textboxTex.File.Padding.Right;

        _font = renderer.GetFontOrDefault(fontId);

        _txt = new(renderer, fontId, text, _lineWidth);
        //GenerateTextures();
    }

    public unsafe void Draw () {
        _textboxTex.Draw(_pos, _size);

        _txt.Draw(new(_pos.X + _textboxTex.File.Padding.Left, _pos.Y + _textboxTex.File.Padding.Top));

        //SDL_FRect dst = new() {
        //    x = _pos.X,
        //    y = _pos.Y,
        //    w = _txt._glyphs[0].ShadowTex->w,
        //    h = _txt._glyphs[0].ShadowTex->h,
        //};
        //
        //SDL3.SDL_RenderTexture(_renderer, _txt._glyphs[0].CharTex, null, &dst);

        //SDL_FRect src = new() {
        //    x = 0,
        //    y = top,
        //    w = _stringTex->w,
        //    h = Math.Min(_stringTex->h - top, _font.Asset.LineHeight * 2),
        //};
        //
        //SDL_FRect srcsh = new() {
        //    x = 0,
        //    y = top,
        //    w = _stringTex->w,
        //    h = 15,
        //};
        //
        //SDL_FRect dst = new() {
        //    x = _pos.X + _textboxTex.File.Padding.Left,
        //    y = _pos.Y + _textboxTex.File.Padding.Top,
        //    w = _stringTex->w,
        //    h = Math.Min(_stringTex->h - top, _font.Asset.LineHeight * 2),
        //};
        //
        //SDL_FRect dstsh = new() {
        //    x = _pos.X + _textboxTex.File.Padding.Left,
        //    y = _pos.Y + _textboxTex.File.Padding.Top,
        //    w = _stringTex->w,
        //    h = 15,
        //};
        //
        //if (_shadowTex is not null) {
        //    SDL3.SDL_RenderTexture(_renderer, _shadowTex, &srcsh, &dstsh);
        //}
        //
        //if (_stringTex is not null) {
        //    SDL3.SDL_RenderTexture(_renderer, _stringTex, &src, &dst);
        //}
    }

    private unsafe void GenerateTextures () {
        if (_renderer is null) return;

        SDL_Color black = new() {
            r = 48,
            g = 80,
            b = 200,
            a = 255
        };
        SDL_Color blackShadow = new() {
            r = 0,
            g = 0,
            b = 0,
            a = Constants.TEXT_SHADOW_ALPHA
        };

        var stringSurface = GenerateSurface(black);
        var shadowSurface = GenerateSurface(blackShadow);

        var stringTex = GenerateStringTexture(_renderer, stringSurface);
        var shadowTex = GenerateShadowTexture(_renderer, shadowSurface);

        _stringTex = stringTex;
        _shadowTex = shadowTex;
    }

    /// <summary>
    /// Given a string and a color, renders said string to a surface.
    /// </summary>
    /// <param name="color">The color to use.</param>
    private unsafe SDL_Surface* GenerateSurface (SDL_Color color) {
        //var surface = SDL3_ttf.TTF_RenderText_Solid_Wrapped(
        //    _font.Font,
        //    _text,
        //    (nuint)_text.Length,
        //    color,
        //    _lineWidth
        //);
        var surface = SDL3_ttf.TTF_RenderGlyph_Solid(_font.Font, 'W', color);

        return surface;
    }

    /// <summary>
    /// Given a surface with rendered text, returns a texture that contains it.
    /// </summary>
    /// <param name="renderer">The renderer that will own the texture.</param>
    /// <param name="surface">The surface to use.</param>
    /// <returns></returns>
    private unsafe SDL_Texture* GenerateStringTexture (SDL_Renderer* renderer, SDL_Surface* surface) {
        var tex = SDL3.SDL_CreateTextureFromSurface(renderer, surface);
        SDL3.SDL_DestroySurface(surface);

        return tex;
    }

    /// <summary>
    /// Given a surface with rendered text, returns a texture that contains an
    /// appropriate pixel shadow for it. The surface given will be destroyed.
    /// </summary>
    /// <param name="renderer">The renderer that will own the texture.</param>
    /// <param name="surface">The surface to use as reference.</param>
    /// <returns></returns>
    private unsafe SDL_Texture* GenerateShadowTexture (
        SDL_Renderer* renderer, SDL_Surface* surface
    ) {
        // Create a raw texture. This is only done to get the format, really.
        var rawTex = SDL3.SDL_CreateTextureFromSurface(renderer, surface); // TODO: Maybe remove this step.

        // Convert the surface to the format we'll use in the streaming texture.
        var compatSurface = SDL3.SDL_ConvertSurface(surface, rawTex->format);

        // Create a texture to draw to.
        var streamingTex = SDL3.SDL_CreateTexture(
            renderer,
            compatSurface->format,
            SDL_TextureAccess.SDL_TEXTUREACCESS_STREAMING,
            rawTex->w,
            _font.Asset.LineHeight
        );

        nint pixels = 0; // The address of the pixels in the streaming texture.
        int pitch = 0; // The pitch in the texture.

        if (SDL3.SDL_LockTexture(streamingTex, null, &pixels, &pitch)) {
            byte* srcPixels = (byte*)compatSurface->pixels;
            byte* dstPixels = (byte*)pixels;

            int srcPitch = compatSurface->pitch;
            int copyWidth = Math.Min(pitch, srcPitch);

            // To compose the shadow, we iterate each pixel in the new texture,
            // and compare it to the surface that contains the rendered text.
            // If said pixel in the surface, or any of its top / left neighbors
            // is not empty, then the pixel in the shadow is not empty.
            // This creates a drop shadow in the bottom-right direction.
            for (int y = 0; y < streamingTex->h; y++) {
                for (int x = 0; x < streamingTex->w; x++) {
                    // The address of this pixel in the texture.
                    byte* dstPix = dstPixels + (y * pitch) + (x * 4);

                    // The address of the pixel in the surface that we'll copy.
                    byte* reference = null;

                    // If this pixel's y is inside the surface, check this
                    // pixel's position in the surface.
                    if (y < compatSurface->h) {
                        byte* srcPix = srcPixels + (y * srcPitch) + (x * 4);

                        if (srcPix[3] != 0) reference = srcPix;
                    }

                    // If reference is still empty, check the pixel in the
                    // surface to the left.
                    if (reference is null && x > 0 && y < compatSurface->h) {
                        byte* left = srcPixels + (y * srcPitch) + ((x - 1) * 4);
                        if (left[3] != 0) reference = left;
                    }
                    // If still empty, check the pixel above.
                    if (reference is null && y > 0 && y <= compatSurface->h) {
                        byte* top = srcPixels + ((y - 1) * srcPitch) + (x * 4);
                        if (top[3] != 0) reference = top;
                    }
                    // If still empty, check the pixel above to the left.
                    if (reference is null && x > 0 && y > 0 && y <= compatSurface->h) {
                        byte* topLeft = srcPixels + ((y - 1) * srcPitch) + ((x - 1) * 4);
                        if (topLeft[3] != 0) reference = topLeft;
                    }

                    // If we have a reference pixel, copy it.
                    if (reference is not null) {
                        dstPix[0] = reference[0];
                        dstPix[1] = reference[1];
                        dstPix[2] = reference[2];
                        dstPix[3] = reference[3];
                    }
                    // Else, this pixel will be transparent.
                    else {
                        dstPix[0] = 0;
                        dstPix[1] = 0;
                        dstPix[2] = 0;
                        dstPix[3] = 0;
                    }
                }
            }

            SDL3.SDL_UnlockTexture(streamingTex);
        }
        else {
            _logger.Error("Failed to copy texture to shadow's streaming texture.");

            // If something failed, we return the raw texture, which won't work
            // as a shadow but will not produce any errors later.
            SDL3.SDL_DestroySurface(surface);
            SDL3.SDL_DestroySurface(compatSurface);
            return rawTex;
        }

        SDL3.SDL_DestroyTexture(rawTex);
        SDL3.SDL_DestroySurface(surface);
        SDL3.SDL_DestroySurface(compatSurface);

        return streamingTex;
    }
}
